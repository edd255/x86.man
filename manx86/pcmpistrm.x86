'\" t
.nh
.TH "X86-PCMPISTRM" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
PCMPISTRM - PACKED COMPARE IMPLICIT LENGTH STRINGS, RETURN MASK
.TS
allbox;
l l l l l 
l l l l l .
\fBOpcode/Instruction\fP	\fBOp/En\fP	\fB64/32 bit Mode Support\fP	\fBCPUID Feature Flag\fP	\fBDescription\fP
T{
66 0F 3A 62 /r imm8 PCMPISTRM xmm1, xmm2/m128, imm8
T}	RM	V/V	SSE4_2	T{
Perform a packed comparison of string data with implicit lengths, generating a mask, and storing the result in XMM0.
T}
T{
VEX.128.66.0F3A.WIG 62 /r ib VPCMPISTRM xmm1, xmm2/m128, imm8
T}	RM	V/V	AVX	T{
Perform a packed comparison of string data with implicit lengths, generating a Mask, and storing the result in XMM0.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l 
l l l l l .
\fBOp/En\fP	\fBOperand 1\fP	\fBOperand 2\fP	\fBOperand 3\fP	\fBOperand 4\fP
RM	ModRM:reg (r)	ModRM:r/m (r)	imm8	N/A
.TE

.SH DESCRIPTION
The instruction compares data from two strings based on the encoded
value in the imm8 byte (see Section 4.1, “Imm8 Control Byte Operation
for PCMPESTRI / PCMPESTRM / PCMPISTRI / PCMPISTRM”) generating a mask
stored to XMM0.

.PP
Each string is represented by a single value. The value is an xmm (or
possibly m128 for the second operand) which contains the data elements
of the string (byte or word data). Each input byte/word is augmented
with a valid/invalid tag. A byte/word is considered valid only if it has
a lower index than the least significant null byte/word. (The least
significant null byte/word is also considered invalid.)

.PP
The comparison and aggregation operation are performed according to the
encoded value of imm8 bit fields (see Section 4.1). As defined by
imm8[6], IntRes2 is then either stored to the least significant bits
of XMM0 (zero extended to 128 bits) or expanded into a byte/word-mask
and then stored to XMM0.

.PP
Note that the Arithmetic Flags are written in a non-standard manner in
order to supply the most relevant information:

.PP
CFlag – Reset if IntRes2 is equal to zero, set otherwise

.PP
ZFlag – Set if any byte/word of xmm2/mem128 is null, reset otherwise

.PP
SFlag – Set if any byte/word of xmm1 is null, reset otherwise

.PP
OFlag – IntRes2[0]

.PP
AFlag – Reset

.PP
PFlag – Reset

.PP
Note: In VEX.128 encoded versions, bits (MAXVL-1:128) of XMM0 are
zeroed. VEX.vvvv is reserved and must be 1111b, VEX.L must be 0,
otherwise the instruction will #UD.

.SH EFFECTIVE OPERAND SIZE
.TS
allbox;
l l l l 
l l l l .
\fBOperating mode/size\fP	\fBOperand 1\fP	\fBOperand 2\fP	\fBResult\fP
16 bit	xmm	xmm/m128	XMM0
32 bit	xmm	xmm/m128	XMM0
64 bit	xmm	xmm/m128	XMM0
.TE

.SH INTEL C/C++ COMPILER INTRINSIC EQUIVALENT FOR RETURNING MASK
__m128i _mm_cmpistrm (__m128i a, __m128i b, const int mode);

.SH INTEL C/C++ COMPILER INTRINSICS FOR READING EFLAG RESULTS
int _mm_cmpistra (__m128i a, __m128i b, const int mode);

.PP
int _mm_cmpistrc (__m128i a, __m128i b, const int mode);

.PP
int _mm_cmpistro (__m128i a, __m128i b, const int mode);

.PP
int _mm_cmpistrs (__m128i a, __m128i b, const int mode);

.PP
int _mm_cmpistrz (__m128i a, __m128i b, const int mode);

.SH SIMD FLOATING-POINT EXCEPTIONS
None.

.SH OTHER EXCEPTIONS
See Table 2-21, “Type 4 Class
Exception Conditions,” additionally, this instruction does not cause
#GP if the memory operand is not aligned to 16 Byte boundary, and:

.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	If VEX.L = 1.
	If VEX.vvvv ≠ 1111B.
.TE

.SH SEE ALSO
x86-manpages(7) for a list of other x86-64 man pages.

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s Manual
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
MIT licensed by TTMO 2025 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
