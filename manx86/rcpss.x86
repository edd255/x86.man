'\" t
.nh
.TH "X86-RCPSS" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
RCPSS - COMPUTE RECIPROCAL OF SCALAR SINGLE PRECISION FLOATING-POINT VALUES
.TS
allbox;
l l l l l 
l l l l l .
\fBOpcode*/Instruction\fP	\fBOp/En\fP	\fB64/32 bit Mode Support\fP	\fBCPUID Feature Flag\fP	\fBDescription\fP
T{
F3 0F 53 /r RCPSS xmm1, xmm2/m32
T}	RM	V/V	SSE	T{
Computes the approximate reciprocal of the scalar single precision floating-point value in xmm2/m32 and stores the result in xmm1.
T}
T{
VEX.LIG.F3.0F.WIG 53 /r VRCPSS xmm1, xmm2, xmm3/m32
T}	RVM	V/V	AVX	T{
Computes the approximate reciprocal of the scalar single precision floating-point value in xmm3/m32 and stores the result in xmm1. Also, upper single precision floating-point values (bits[127:32]) from xmm2 are copied to xmm1[127:32]\&.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l 
l l l l l .
\fBOp/En\fP	\fBOperand 1\fP	\fBOperand 2\fP	\fBOperand 3\fP	\fBOperand 4\fP
RM	ModRM:reg (w)	ModRM:r/m (r)	N/A	N/A
RVM	ModRM:reg (w)	VEX.vvvv (r)	ModRM:r/m (r)	N/A
.TE

.SH DESCRIPTION
Computes of an approximate reciprocal of the low single precision
floating-point value in the source operand (second operand) and stores
the single precision floating-point result in the destination operand.
The source operand can be an XMM register or a 32-bit memory location.
The destination operand is an XMM register. The three high-order
doublewords of the destination operand remain unchanged. See
Figure 10-6 in the Intel® 64 and IA-32
Architectures Software Developer’s Manual, Volume 1, for an illustration
of a scalar single precision floating-point operation.

.PP
The relative error for this approximation is:

.PP
|Relative Error| ≤ 1.5 ∗ 2−12

.PP
The RCPSS instruction is not affected by the rounding control bits in
the MXCSR register. When a source value is a 0.0, an ∞ of the sign of
the source value is returned. A denormal source value is treated as a
0.0 (of the same sign). Tiny results (see Section 4.9.1.5, “Numeric
Underflow Exception (#U)” in Intel126| are guaranteed to produce tiny
results, which are in turn flushed to 0.0; and input values in between
this range may or may not produce tiny results, depending on the
implementation.) When a source value is an SNaN or QNaN, the SNaN is
converted to a QNaN or the source QNaN is returned.

.PP
In 64-bit mode, using a REX prefix in the form of REX.R permits this
instruction to access additional registers (XMM8-XMM15).

.PP
128-bit Legacy SSE version: The first source operand and the destination
operand are the same. Bits (MAXVL-1:32) of the corresponding YMM
destination register remain unchanged.

.PP
VEX.128 encoded version: Bits (MAXVL-1:128) of the destination YMM
register are zeroed.

.SH OPERATION
.SS RCPSS (128-bit Legacy SSE Version)
.EX
DEST[31:0] := APPROXIMATE(1/SRC[31:0])
DEST[MAXVL-1:32] (Unmodified)
.EE

.SS VRCPSS (VEX.128 Encoded Version)
.EX
DEST[31:0] := APPROXIMATE(1/SRC2[31:0])
DEST[127:32] := SRC1[127:32]
DEST[MAXVL-1:128] := 0
.EE

.SH INTEL C/C++ COMPILER INTRINSIC EQUIVALENT
.EX
RCPSS __m128 _mm_rcp_ss(__m128 a)
.EE

.SH SIMD FLOATING-POINT EXCEPTIONS
None.

.SH OTHER EXCEPTIONS
See Table 2-22, “Type 5 Class
Exception Conditions.”

.SH SEE ALSO
x86-manpages(7) for a list of other x86-64 man pages.

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s Manual
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
MIT licensed by TTMO 2025 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
