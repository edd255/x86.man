'\" t
.nh
.TH "X86-PCMPISTRI" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
PCMPISTRI - PACKED COMPARE IMPLICIT LENGTH STRINGS, RETURN INDEX
.TS
allbox;
l l l l l 
l l l l l .
\fBOpcode/Instruction\fP	\fBOp/En\fP	\fB64/32 bit Mode Support\fP	\fBCPUID Feature Flag\fP	\fBDescription\fP
T{
66 0F 3A 63 /r imm8 PCMPISTRI xmm1, xmm2/m128, imm8
T}	RM	V/V	SSE4_2	T{
Perform a packed comparison of string data with implicit lengths, generating an index, and storing the result in ECX.
T}
T{
VEX.128.66.0F3A.WIG 63 /r ib VPCMPISTRI xmm1, xmm2/m128, imm8
T}	RM	V/V	AVX	T{
Perform a packed comparison of string data with implicit lengths, generating an index, and storing the result in ECX.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l 
l l l l l .
\fBOp/En\fP	\fBOperand 1\fP	\fBOperand 2\fP	\fBOperand 3\fP	\fBOperand 4\fP
RM	ModRM:reg (r)	ModRM:r/m (r)	imm8	N/A
.TE

.SH DESCRIPTION
The instruction compares data from two strings based on the encoded
value in the imm8 control byte (see Section 4.1, “Imm8 Control Byte
Operation for PCMPESTRI / PCMPESTRM / PCMPISTRI / PCMPISTRM”), and
generates an index stored to ECX.

.PP
Each string is represented by a single value. The value is an xmm (or
possibly m128 for the second operand) which contains the data elements
of the string (byte or word data). Each input byte/word is augmented
with a valid/invalid tag. A byte/word is considered valid only if it has
a lower index than the least significant null byte/word. (The least
significant null byte/word is also considered invalid.)

.PP
The comparison and aggregation operations are performed according to the
encoded value of imm8 bit fields (see Section 4.1). The index of the
first (or last, according to imm8[6]) set bit of IntRes2 is returned
in ECX. If no bits are set in IntRes2, ECX is set to 16 (8).

.PP
Note that the Arithmetic Flags are written in a non-standard manner in
order to supply the most relevant information:

.PP
CFlag – Reset if IntRes2 is equal to zero, set otherwise

.PP
ZFlag – Set if any byte/word of xmm2/mem128 is null, reset otherwise

.PP
SFlag – Set if any byte/word of xmm1 is null, reset otherwise

.PP
OFlag –IntRes2[0]

.PP
AFlag – Reset

.PP
PFlag – Reset

.PP
Note: In VEX.128 encoded version, VEX.vvvv is reserved and must be
1111b, VEX.L must be 0, otherwise the instruction will #UD.

.SH EFFECTIVE OPERAND SIZE
.TS
allbox;
l l l l 
l l l l .
\fBOperating mode/size\fP	\fBOperand 1\fP	\fBOperand 2\fP	\fBResult\fP
16 bit	xmm	xmm/m128	ECX
32 bit	xmm	xmm/m128	ECX
64 bit	xmm	xmm/m128	ECX
.TE

.SH INTEL C/C++ COMPILER INTRINSIC EQUIVALENT FOR RETURNING INDEX
int _mm_cmpistri (__m128i a, __m128i b, const int mode);

.SH INTEL C/C++ COMPILER INTRINSICS FOR READING EFLAG RESULTS
int _mm_cmpistra (__m128i a, __m128i b, const int mode);

.PP
int _mm_cmpistrc (__m128i a, __m128i b, const int mode);

.PP
int _mm_cmpistro (__m128i a, __m128i b, const int mode);

.PP
int _mm_cmpistrs (__m128i a, __m128i b, const int mode);

.PP
int _mm_cmpistrz (__m128i a, __m128i b, const int mode);

.SH SIMD FLOATING-POINT EXCEPTIONS
None.

.SH OTHER EXCEPTIONS
See Table 2-21, “Type 4 Class
Exception Conditions,” additionally, this instruction does not cause
#GP if the memory operand is not aligned to 16 Byte boundary, and:

.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	If VEX.L = 1.
	If VEX.vvvv ≠ 1111B.
.TE

.SH SEE ALSO
x86-manpages(7) for a list of other x86-64 man pages.

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s Manual
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
MIT licensed by TTMO 2025 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
