'\" t
.nh
.TH "X86-LDTILECFG" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
LDTILECFG - LOAD TILE CONFIGURATION
.TS
allbox;
l l l l l 
l l l l l .
\fBOpcode/Instruction\fP	\fBOp/En\fP	\fB64/32 bit Mode Support\fP	\fBCPUID Feature Flag\fP	\fBDescription\fP
T{
VEX.128.NP.0F38.W0 49 !(11):000:bbb LDTILECFG m512
T}	A	V/N.E.	AMX-TILE	T{
Load tile configuration as specified in m512.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l l 
l l l l l l .
\fBOp/En\fP	\fBTuple\fP	\fBOperand 1\fP	\fBOperand 2\fP	\fBOperand 3\fP	\fBOperand 4\fP
A	N/A	ModRM:r/m (r)	N/A	N/A	N/A
.TE

.SS Description
The LDTILECFG instruction takes an operand containing a pointer to a
64-byte memory location containing the description of the tiles to be
supported. In order to configure the tiles, the AMX-TILE bit in CPUID
must be set and the operating system has to have enabled the tiles
architecture.

.PP
The memory area contains the palette and describes how many tiles are
being used and defines each tile in terms of rows and column bytes.
Requests must be compatible with the restrictions provided by CPUID; see
Table 3-10 below.

.PP
If a tile row and column pair is not used to specify tile parameters,
they must have the value zero. All enabled tiles (based on the palette)
must be configured. Specifying tile parameters for more tiles than the
implementation limit or the palette limit results in a #GP fault.

.PP
If the palette_id is zero, that signifies the INIT state for both
TILECFG and TILEDATA. Tiles are zeroed in the INIT state. The only legal
non-INIT value for palette_id is 1.

.PP
Any attempt to execute the LDTILECFG instruction inside an Intel TSX
transaction will result in a transaction abort.

.SS Operation
.SS LDTILECFG mem
.EX
error := False
buf := read_memory(mem, 64)
temp_tilecfg.palette_id := buf.byte[0]
if temp_tilecfg.palette_id > max_palette:
    error := True
if not xcr0_supports_palette(temp_tilecfg.palette_id):
    error := True
if temp_tilecfg.palette_id !=0:
    temp_tilecfg.start_row := buf.byte[1]
    if buf.byte[2..15] is nonzero:
        error := True
    p := 16
    # configure columns
    for n in 0 ... palette_table[temp_tilecfg.palette_id].max_names-1:
        temp_tilecfg.t[n].colsb:= buf.word[p/2]
        p := p + 2
        if temp_tilecfg.t[n].colsb > palette_table[temp_tilecfg.palette_id].bytes_per_row:
            error := True
    if nonzero(buf[p...47]):
        error := True
    # configure rows
    p := 48
    for n in 0 ... palette_table[temp_tilecfg.palette_id].max_names-1:
        temp_tilecfg.t[n].rows:= buf.byte[p]
        if temp_tilecfg.t[n].rows > palette_table[temp_tilecfg.palette_id].max_rows:
            error := True
        p := p + 1
    if nonzero(buf[p...63]):
        error := True
    # validate each tile's row & col configs are reasonable and enable the valid tiles
    for n in 0 ... palette_table[temp_tilecfg.palette_id].max_names-1:
        if temp_tilecfg.t[n].rows !=0 and temp_tilecfg.t[n].colsb != 0:
            temp_tilecfg.t[n].valid := 1
        elif temp_tilecfg.t[n].rows == 0 and temp_tilecfg.t[n].colsb == 0:
            temp_tilecfg.t[n].valid := 0
        else:
            error := True// one of rows or colsbwas 0 but not both.
if error:
    #GP
elif temp_tilecfg.palette_id == 0:
    TILES_CONFIGURED := 0// init state
    tilecfg := 0// equivalent to 64B of zeros
    zero_all_tile_data()
else:
    tilecfg := temp_tilecfg
    zero_all_tile_data()
    TILES_CONFIGURED := 1
.EE

.SS Intel C/C++ Compiler Intrinsic Equivalent
.EX
LDTILECFG void _tile_loadconfig(const void *);
.EE

.SS Flags Affected
None.

.SS Exceptions
AMX-E1; see Section 2.10, “Intel® AMX Instruction Exception Classes,”
for details.

.SH SEE ALSO
x86-manpages(7) for a list of other x86-64 man pages.

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s Manual
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
MIT licensed by TTMO 2025 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
