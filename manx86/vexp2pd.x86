'\" t
.nh
.TH "X86-VEXP2PD" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
VEXP2PD - APPROXIMATION TO THE EXPONENTIAL 2^X OF PACKED DOUBLE PRECISION FLOATING-POINTVALUES WITH LESS THAN 2^-23 RELATIVE ERROR
.TS
allbox;
l l l l l 
l l l l l .
\fBOpcode/Instruction\fP	\fBOp/En\fP	\fB64/32 bit Mode Support\fP	\fBCPUID Feature Flag\fP	\fBDescription\fP
T{
EVEX.512.66.0F38.W1 C8 /r VEXP2PD zmm1 {k1}{z}, zmm2/m512/m64bcst {sae}
T}	A	V/V	AVX512ER	T{
Computes approximations to the exponential 2^x (with less than 2^-23 of maximum relative error) of the packed double precision floating-point values from zmm2/m512/m64bcst and stores the floating-point result in zmm1with writemask k1.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l l 
l l l l l l .
\fBOp/En Tuple Type Operand 1 Operand 2 Operand 3 Operand 4\fP	\fB\fP	\fB\fP	\fB\fP	\fB\fP	\fB\fP
T{
A Full ModRM:reg (r, w) ModRM:r/m (r) N/A N/A
T}					
.TE

.SS Description
Computes the approximate base-2 exponential evaluation of the double
precision floating-point values in the source operand (the second
operand) and stores the results to the destination operand (the first
operand) using the writemask k1. The approximate base-2 exponential is
evaluated with less than 2^-23 of relative error.

.PP
Denormal input values are treated as zeros and do not signal #DE,
irrespective of MXCSR.DAZ. Denormal results are flushed to zeros and do
not signal #UE, irrespective of MXCSR.FTZ.

.PP
The source operand is a ZMM register, a 512-bit memory location or a
512-bit vector broadcasted from a 64-bit memory location. The
destination operand is a ZMM register, conditionally updated using
writemask k1.

.PP
EVEX.vvvv is reserved and must be 1111b otherwise instructions will
#UD.

.SS A numerically exact implementation of VEXP2xx can be found at https://software.intel.com/en-us/articles/refer-
.SS ence-implementations-for-IA-approximation-instructions-vrcp14-vrsqrt14-vrcp28-vrsqrt28-vexp2.
.SS Operation
.SS VEXP2PD
.EX
(KL, VL) = (8, 512)
FOR j := 0 TO KL-1
    i := j * 64
    IF k1[j] OR *no writemask* THEN
            IF (EVEX.b = 1) AND (SRC *is memory*)
                THEN DEST[i+63:i] := EXP2_23_DP(SRC[63:0])
                ELSE DEST[i+63:i] := EXP2_23_DP(SRC[i+63:i])
            FI;
    ELSE
        IF *merging-masking* ; merging-masking
            THEN *DEST[i+63:i] remains unchanged*
            ELSE ; zeroing-masking
                DEST[i+63:i] := 0
        FI;
    FI;
ENDFOR;
.EE

.SS Intel C/C++ Compiler Intrinsic Equivalent
.EX
VEXP2PD __m512d _mm512_exp2a23_round_pd (__m512d a, int sae);

VEXP2PD __m512d _mm512_mask_exp2a23_round_pd (__m512d a, __mmask8 m, __m512d b, int sae);

VEXP2PD __m512d _mm512_maskz_exp2a23_round_pd ( __mmask8 m, __m512d b, int sae);
.EE

.SS SIMD Floating-Point Exceptions
Invalid (if SNaN input), Overflow.

.SS Other Exceptions
See Table 2-46, “Type E2 Class
Exception Conditions.”

.SH SEE ALSO
x86-manpages(7) for a list of other x86-64 man pages.

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s Manual
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
MIT licensed by TTMO 2025 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
