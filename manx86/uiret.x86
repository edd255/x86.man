'\" t
.nh
.TH "X86-UIRET" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
UIRET - USER-INTERRUPT RETURN
.TS
allbox;
l l l l l 
l l l l l .
\fBOpcode/Instruction\fP	\fBOp/En\fP	\fB64/32 bit Mode Support\fP	\fBCPUID Feature Flag\fP	\fBDescription\fP
F3 0F 01 EC UIRET	ZO	V/I	UINTR	T{
Return from handling a user interrupt.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l l 
l l l l l l .
\fBOp/En\fP	\fBTuple\fP	\fBOperand 1\fP	\fBOperand 2\fP	\fBOperand 3\fP	\fBOperand 4\fP
ZO	N/A	N/A	N/A	N/A	N/A
.TE

.SH DESCRIPTION
UIRET returns from the handling of a user interrupt. It can be executed
regardless of CPL.

.PP
Execution of UIRET inside a transactional region causes a transactional
abort; the abort loads EAX as it would have had it been due to an
execution of IRET.

.PP
UIRET can be tracked by Architectural Last Branch Records (LBRs), Intel
Processor Trace (Intel PT), and Performance Monitoring. For both Intel
PT and LBRs, UIRET is recorded in precisely the same manner as IRET.
Hence for LBRs, UIRETs fall into the OTHER_BRANCH category, which
implies that IA32_LBR_CTL.OTHER_BRANCH[bit 22] must be set to
record user-interrupt delivery, and that the IA32_LBR_x_INFO.BR_TYPE
field will indicate OTHER_BRANCH for any recorded user interrupt. For
Intel PT, control flow tracing must be enabled by setting
IA32_RTIT_CTL.BranchEn[bit 13]\&.

.PP
UIRET will also increment performance counters for which counting
BR_INST_RETIRED.FAR_BRANCH is enabled.

.SH OPERATION
.EX
Pop tempRIP;
Pop tempRFLAGS; // see below for how this is used to load RFLAGS
Pop tempRSP;
IF tempRIP is not canonical in current paging mode
    THEN #GP(0);
FI;
IF ShadowStackEnabled(CPL)
    THEN
        PopShadowStack SSRIP;
        IF SSRIP ≠ tempRIP
            THEN #CP (FAR-RET/IRET);
        FI;
FI;
RIP := tempRIP;
// update in RFLAGS only CF, PF, AF, ZF, SF, TF, DF, OF, NT, RF, AC, and ID
RFLAGS := (RFLAGS & ~254DD5H) | (tempRFLAGS & 254DD5H);
RSP := tempRSP;
UIF := 1;
Clear any cache-line monitoring established by MONITOR or UMONITOR;
.EE

.SH FLAGS AFFECTED
See the Operation section.

.SH PROTECTED MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	T{
The UIRET instruction is not recognized in protected mode.
T}
.TE

.SH REAL-ADDRESS MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	T{
The UIRET instruction is not recognized in real-address mode.
T}
.TE

.SH VIRTUAL-8086 MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	T{
The UIRET instruction is not recognized in virtual-8086 mode.
T}
.TE

.SH COMPATIBILITY MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	T{
The UIRET instruction is not recognized in compatibility mode.
T}
.TE

.SH 64-BIT MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#GP(0)	T{
If the return instruction pointer is non-canonical.
T}
#SS(0)	T{
If an attempt to pop a value off the stack causes a non-canonical address to be referenced.
T}
#PF(fault-code)	If a page fault occurs.
#AC(0)	T{
If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.
T}
#CP	T{
If return instruction pointer from stack and shadow stack do not match.
T}
#UD	If the LOCK prefix is used.
	If executed inside an enclave.
	If CR4.UINTR = 0.
	If CPUID.07H.0H:EDX.UINTR[bit 5] = 0.
.TE

.SH SEE ALSO
x86-manpages(7) for a list of other x86-64 man pages.

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s Manual
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
MIT licensed by TTMO 2025 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
