'\" t
.nh
.TH "X86-LOOP-LOOPCC" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
LOOP-LOOPCC - LOOP ACCORDING TO ECX COUNTER
.TS
allbox;
l l l l l l 
l l l l l l .
\fBOpcode\fP	\fBInstruction\fP	\fBOp/En\fP	\fB64-Bit Mode\fP	\fBCompat/Leg Mode\fP	\fBDescription\fP
E2 cb	LOOP rel8	D	Valid	Valid	T{
Decrement count; jump short if count ≠ 0.
T}
E1 cb	LOOPE rel8	D	Valid	Valid	T{
Decrement count; jump short if count ≠ 0 and ZF = 1.
T}
E0 cb	LOOPNE rel8	D	Valid	Valid	T{
Decrement count; jump short if count ≠ 0 and ZF = 0.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l 
l l l l l .
\fBOp/En Operand 1 Operand 2 Operand 3\fP	\fB\fP	\fB\fP	\fB\fP	\fBOperand 4\fP
D Offset N/A N/A				N/A
.TE

.SH DESCRIPTION
Performs a loop operation using the RCX, ECX or CX register as a counter
(depending on whether address size is 64 bits, 32 bits, or 16 bits).
Note that the LOOP instruction ignores REX.W; but 64-bit address size
can be over-ridden using a 67H prefix.

.PP
Each time the LOOP instruction is executed, the count register is
decremented, then checked for 0. If the count is 0, the loop is
terminated and program execution continues with the instruction
following the LOOP instruction. If the count is not zero, a near jump is
performed to the destination (target) operand, which is presumably the
instruction at the beginning of the loop.

.PP
The target instruction is specified with a relative offset (a signed
offset relative to the current value of the instruction pointer in the
IP/EIP/RIP register). This offset is generally specified as a label in
assembly code, but at the machine code level, it is encoded as a signed,
8-bit immediate value, which is added to the instruction pointer.
Offsets of –128 to +127 are allowed with this instruction.

.PP
Some forms of the loop instruction (LOOPcc instruction itself does not
affect the state of the ZF flag; the ZF flag is changed by other
instructions in the loop.

.SH OPERATION
.EX
IF (AddressSize = 32)
    THEN Count is ECX;
ELSE IF (AddressSize = 64)
    Count is RCX;
ELSE Count is CX;
FI;
Count := Count – 1;
IF Instruction is not LOOP
    THEN
        IF (Instruction := LOOPE) or (Instruction := LOOPZ)
            THEN IF (ZF = 1) and (Count ≠ 0)
                    THEN BranchCond := 1;
                    ELSE BranchCond := 0;
                FI;
            ELSE (Instruction = LOOPNE) or (Instruction = LOOPNZ)
                IF (ZF = 0 ) and (Count ≠ 0)
                    THEN BranchCond := 1;
                    ELSE BranchCond := 0;
        FI;
    ELSE (* Instruction = LOOP *)
        IF (Count ≠ 0)
            THEN BranchCond := 1;
            ELSE BranchCond := 0;
        FI;
FI;
IF BranchCond = 1
    THEN
        IF in 64-bit mode (* OperandSize = 64 *)
            THEN
                tempRIP := RIP + SignExtend(DEST);
                IF tempRIP is not canonical
                    THEN #GP(0);
                ELSE RIP := tempRIP;
                FI;
            ELSE
                tempEIP := EIP SignExtend(DEST);
                IF OperandSize 16
                    THEN tempEIP := tempEIP AND 0000FFFFH;
                FI;
                IF tempEIP is not within code segment limit
                    THEN #GP(0);
                    ELSE EIP := tempEIP;
                FI;
        FI;
    ELSE
        Terminate loop and continue program execution at (R/E)IP;
FI;
.EE

.SH FLAGS AFFECTED
None.

.SH PROTECTED MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#GP(0)	T{
If the offset being jumped to is beyond the limits of the CS segment.
T}
#UD	If the LOCK prefix is used.
.TE

.SH REAL-ADDRESS MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#GP	T{
If the offset being jumped to is beyond the limits of the CS segment or is outside of the effective address space from 0 to FFFFH. This condition can occur if a 32-bit address size override prefix is used.
T}
#UD	If the LOCK prefix is used.
.TE

.SH VIRTUAL-8086 MODE EXCEPTIONS
Same exceptions as in real address mode.

.SH COMPATIBILITY MODE EXCEPTIONS
Same exceptions as in protected mode.

.SH 64-BIT MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#GP(0)	T{
If the offset being jumped to is in a non-canonical form.
T}
#UD	If the LOCK prefix is used.
.TE

.SH SEE ALSO
x86-manpages(7) for a list of other x86-64 man pages.

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s Manual
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
MIT licensed by TTMO 2025 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
