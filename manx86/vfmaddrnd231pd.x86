'\" t
.nh
.TH "X86-VFMADDRND231PD" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
VFMADDRND231PD - FUSED MULTIPLY-ADD OF PACKED DOUBLE-PRECISION FLOATING-POINT VALUESWITH ROUNDING CONTROL
.TS
allbox;
l 
l .
\fB\fP
T{
Opcode/ Mode CPUID Description Instruction Support Feature Flag VEX.DDS.128.66.0F3A.W1 B8 /r /ib V/V FMA Multiply packed double-precision floating-point values from xmm1 VFMADDRND231PD xmm0, and xmm2/mem, add to xmm0 and xmm1, xmm2/m128, imm8 put result in xmm0. VEX.DDS.256.66.0F3A.W1 B8 /r /ib V/V FMA Multiply packed double-precision floating-point values from ymm1 VFMADDRND231PD ymm0, and ymm2/mem, add to ymm0 and ymm1, ymm2/m256, imm8 put result in ymm0.
T}
.TE

.SH DESCRIPTION
Multiplies the two or four packed double-precision floating-point values
from the second source operand to the two or four packed
double-precision floating-point values in the third source operand, adds
the infinite precision intermediate result to the two or four packed
double-precision floating-point values in the first source operand,
performs rounding and stores the resulting two or four packed
double-precision floating-point values to the destination operand (first
source operand).

.PP
The immediate byte defines several bit fields that control rounding,
DAZ, FTZ, and exception suppression (SeeTable 5-3).The rounding mode
specified in MXCSR.RC may be bypassed if the immediate bit called MS1
(MXCSR.RC Override) is set. Likewise, the MXCSR.FTZ and MXCSR.DAZ may
also be bypassed if the immediate bit called MS2 (MXCSR.FTZ/DAZ
Override) is set. In case SAE (Suppress All Exceptions) bit is set (i.e.
imm8[3] = 1), the status flags in MXCSR are not updated and no SIMD
floating-point exceptions are raised. When SAE bit is not set (i.e.
imm8[3] = 0) then SIMD floating-point exceptions are signaled
according to the MXCSR. If any result operand is an SNaN then it will be
converted to a QNaN.

.PP
VEX.256 encoded version: The destination operand (also first source
operand) is a YMM register and encoded in reg_field. The second source
operand is a YMM register and encoded in VEX.vvvv. The third source
operand is a YMM register or a 256-bit memory location and encoded in
rm_field.

.PP
VEX.128 encoded version: The destination operand (also first source
operand) is a XMM register and encoded in reg_field. The second source
operand is a XMM register and encoded in VEX.vvvv. The third source
operand is a XMM register or a 128-bit memory location and encoded in
rm_field. The upper 128 bits of the YMM destination register are
zeroed.

.PP
Compiler tools may optionally support the complementary mnemonic
VMADDRND321PD. The behavior of the complementary mnemonic in situations
involving NANs are governed by the definition of the instruction
mnemonic defined in the opcode/instruction column. See also Section
2.3.1, “FMA Instruction Operand Order and Arithmetic Behavior”

.SH OPERATION
.EX
In the operations below, “+” and “*” symbols represent multiplication and addition with infinite precision inputs and outputs (no rounding)
.EE

.SS VFMADDRND231PD DEST, SRC2, SRC3, imm8
.EX
IF (VEX.128) THEN
    MAXVL =2
ELSEIF (VEX.256)
    MAXVL = 4
FI
IF (imm8[3] = 1) THEN
    Suppress_SIMD_Exception_Signaling_Reporting();
FI
For i = 0 to MAXVL-1 {
    n = 64*i;
    DEST[n+63:n]←RoundFPControl_Imm((SRC2[n+63:n]*SRC3[n+63:n] + DEST[n+63:n]), imm8)
}
IF (VEX.128) THEN
DEST[255:128] ← 0
FI
IF (imm8[3] = 1) THEN
    Resume_SIMD_Exception_Signaling_Reporting();
FI
.EE

.SH INTEL C/C++ COMPILER INTRINSIC EQUIVALENT
.EX
VFMADDRND231PD __m128d _mm_fmaddround_pd (__m128d a, __m128d b, __m128d c, const int ctrl);

VFMADDRND231PD __m256d _mm256_fmaddround_pd (__m256d a, __m256d b, __m256d c, const int ctrl);
.EE

.SH SIMD FLOATING-POINT EXCEPTIONS
IF imm[3] = 1 Then

.PP
None

.PP
Else

.PP
Overflow, Underflow, Invalid, Precision, Denormal

.PP
FI

.SH OTHER EXCEPTIONS
See Exceptions Type 2

.SH SEE ALSO
x86-manpages(7) for a list of other x86-64 man pages.

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s Manual
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
MIT licensed by TTMO 2025 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
