'\" t
.nh
.TH "X86-VCOMISH" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
VCOMISH - COMPARE SCALAR ORDERED FP16 VALUES AND SET EFLAGS
.TS
allbox;
l l l l l 
l l l l l .
\fB\fP	\fB\fP	\fB\fP	\fB\fP	\fB\fP
T{
Instruction En Bit Mode Flag Support Instruction En Bit Mode Flag Support 64/32 CPUID Feature Instruction En Bit Mode Flag CPUID Feature Instruction En Bit Mode Flag Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag 64/32 CPUID Feature Instruction En Bit Mode Flag CPUID Feature Instruction En Bit Mode Flag Op/ 64/32 CPUID Feature
T}		Support		Description
VCOMISH xmm1, xmm2/m16 {sae}				T{
Compare low FP16 values in xmm1 and xmm2/m16, and set the EFLAGS flags accordingly.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l l 
l l l l l l .
\fBOp/En\fP	\fBTuple\fP	\fBOperand 1\fP	\fBOperand 2\fP	\fBOperand 3\fP	\fBOperand 4\fP
A	Scalar	ModRM:reg (r)	ModRM:r/m (r)	N/A	N/A
.TE

.SS Description
This instruction compares the FP16 values in the low word of operand 1
(first operand) and operand 2 (second operand), and sets the ZF, PF, and
CF flags in the EFLAGS register according to the result (unordered,
greater than, less than, or equal). The OF, SF and AF flags in the
EFLAGS register are set to 0. The unordered result is returned if either
source operand is a NaN (QNaN or SNaN).

.PP
Operand 1 is an XMM register; operand 2 can be an XMM register or a
16-bit memory location.

.PP
The VCOMISH instruction differs from the VUCOMISH instruction in that it
signals a SIMD floating-point invalid operation exception (#I) when a
source operand is either a QNaN or SNaN. The VUCOMISH instruction
signals an invalid numeric exception only if a source operand is an
SNaN.

.PP
The EFLAGS register is not updated if an unmasked SIMD floating-point
exception is generated. EVEX.vvvv is reserved and must be 1111b,
otherwise instructions will #UD.

.SS Operation
.SS VCOMISH SRC1, SRC2
.EX
RESULT := OrderedCompare(SRC1.fp16[0],SRC2.fp16[0])
IF RESULT is UNORDERED:
    ZF, PF, CF := 1, 1, 1
ELSE IF RESULT is GREATER_THAN:
    ZF, PF, CF := 0, 0, 0
ELSE IF RESULT is LESS_THAN:
    ZF, PF, CF := 0, 0, 1
ELSE: // RESULT is EQUALS
    ZF, PF, CF := 1, 0, 0
OF, AF, SF := 0, 0, 0
.EE

.SS Intel C/C++ Compiler Intrinsic Equivalent
.EX
VCOMISH int _mm_comi_round_sh (__m128h a, __m128h b, const int imm8, const int sae);

VCOMISH int _mm_comi_sh (__m128h a, __m128h b, const int imm8);

VCOMISH int _mm_comieq_sh (__m128h a, __m128h b);

VCOMISH int _mm_comige_sh (__m128h a, __m128h b);

VCOMISH int _mm_comigt_sh (__m128h a, __m128h b);

VCOMISH int _mm_comile_sh (__m128h a, __m128h b);

VCOMISH int _mm_comilt_sh (__m128h a, __m128h b);

VCOMISH int _mm_comineq_sh (__m128h a, __m128h b);
.EE

.SS SIMD Floating-Point Exceptions
Invalid, Denormal.

.SS Other Exceptions
EVEX-encoded instructions, see Table
2-48, “Type E3NF Class Exception Conditions.”

.SH SEE ALSO
x86-manpages(7) for a list of other x86-64 man pages.

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s Manual
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
MIT licensed by TTMO 2025 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
