'\" t
.nh
.TH "X86-AESENC256KL" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
AESENC256KL - PERFORM 14 ROUNDS OF AES ENCRYPTION FLOW WITH KEY LOCKER USING 256-BIT KEY
.TS
allbox;
l l l l l 
l l l l l .
\fBOpcode/Instruction\fP	\fBOp/En\fP	\fB64/32-bit Mode\fP	\fBCPUID Feature Flag\fP	\fBDescription\fP
T{
F3 0F 38 DE !(11):rrr:bbb AESENC256KL xmm, m512
T}	A	V/V	AESKLE	T{
Encrypt xmm using 256-bit AES key indicated by handle at m512 and store result in xmm.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l l 
l l l l l l .
\fBOp/En\fP	\fBTuple\fP	\fBOperand 1\fP	\fBOperand 2\fP	\fBOperand 3\fP	\fBOperand 4\fP
A	N/A	ModRM:reg (r, w)	ModRM:r/m (r)	N/A	N/A
.TE

.SH DESCRIPTION
The AESENC256KL1 instruction performs 14 rounds of AES to encrypt the
first operand using the 256-bit key indicated by the handle from the
second operand. It stores the result in the first operand if the
operation succeeds (e.g., does not run into a handle violation failure).

.SH OPERATION
.SS AESENC256KL
.EX
Handle := UnalignedLoad of 512 bit (SRC); // Load is not guaranteed to be atomic.
Illegal Handle = (
                HandleReservedBitSet (Handle) ||
                (Handle[0] AND (CPL > 0)) ||
                Handle [1] ||
                HandleKeyType (Handle) != HANDLE_KEY_TYPE_AES256
                );
IF (Illegal Handle)
    THEN RFLAGS.ZF := 1;
    ELSE
        (UnwrappedKey, Authentic) := UnwrapKeyAndAuthenticate512 (Handle[511:0], IWKey);
        IF (Authentic == 0)
            THEN RFLAGS.ZF := 1;
            ELSE
                    DEST := AES256Encrypt (DEST, UnwrappedKey) ;
                    RFLAGS.ZF := 0;
        FI;
FI;
RFLAGS.OF, SF, AF, PF, CF := 0;
.EE

.SH FLAGS AFFECTED
ZF is set to 0 if the operation succeeded and set to 1 if the operation
failed due to a handle violation. The other arithmetic flags (OF, SF,
AF, PF, CF) are cleared to 0.

.SH INTEL C/C++ COMPILER INTRINSIC EQUIVALENT
.EX
AESENC256KL unsigned char _mm_aesenc256kl_u8(__m128i* odata, __m128i idata, const void* h);

1. Further details on Key Locker and usage of this instruction can be found here:
.EE

.SS https://software.intel.com/content/www/us/en/develop/download/intel-key-locker-specification.html.
.SH EXCEPTIONS (ALL OPERATING MODES)
#UD If the LOCK prefix is used.

.PP
If CPUID.07H:ECX.KL[bit 23] = 0.

.PP
If CR4.KL = 0.

.PP
If CPUID.19H:EBX.AESKLE[bit 0] = 0.

.PP
If CR0.EM = 1.

.PP
If CR4.OSFXSR = 0.

.PP
#NM If CR0.TS = 1.

.PP
#PF If a page fault occurs.

.PP
#GP(0) If a memory operand effective address is outside the CS, DS, ES,
FS, or GS segment limit.

.PP
If the DS, ES, FS, or GS register is used to access memory and it
contains a NULL segment selector.

.PP
If the memory address is in a non-canonical form.

.PP
#SS(0) If a memory operand effective address is outside the SS segment
limit.

.PP
If a memory address referencing the SS segment is in a non-canonical
form.

.SH SEE ALSO
x86-manpages(7) for a list of other x86-64 man pages.

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s Manual
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
MIT licensed by TTMO 2025 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
