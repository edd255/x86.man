'\" t
.nh
.TH "X86-TILELOADD-TILELOADDT1" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
TILELOADD-TILELOADDT1 - LOAD TILE
.TS
allbox;
l l l l l 
l l l l l .
\fBOpcode/Instruction\fP	\fBOp/En\fP	\fB64/32 bit Mode Support\fP	\fBCPUID Feature Flag\fP	\fBDescription\fP
T{
VEX.128.F2.0F38.W0 4B !(11):rrr:100 TILELOADD tmm1, sibmem
T}	A	V/N.E.	AMX-TILE	T{
Load data into tmm1 as specified by information in sibmem.
T}
T{
VEX.128.66.0F38.W0 4B !(11):rrr:100 TILELOADDT1 tmm1, sibmem
T}	A	V/N.E.	AMX-TILE	T{
Load data into tmm1 as specified by information in sibmem with hint to optimize data caching.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l l 
l l l l l l .
\fBOp/En\fP	\fBTuple\fP	\fBOperand 1\fP	\fBOperand 2\fP	\fBOperand 3\fP	\fBOperand 4\fP
A	N/A	ModRM:reg (w)	ModRM:r/m (r)	N/A	N/A
.TE

.SH DESCRIPTION
This instruction is required to use SIB addressing. The index register
serves as a stride indicator. If the SIB encoding omits an index
register, the value zero is assumed for the content of the index
register.

.PP
This instruction loads a tile destination with rows and columns as
specified by the tile configuration. The “T1” version provides a hint to
the implementation that the data would be reused but does not need to be
resident in the nearest cache levels.

.PP
The TILECFG.start_row in the TILECFG data should be initialized to '0'
in order to load the entire tile and is set to zero on successful
completion of the TILELOADD instruction. TILELOADD is a restartable
instruction and the TILECFG.start_row will be non-zero when restartable
events occur during the instruction execution.

.PP
Only memory operands are supported and they can only be accessed using a
SIB addressing mode, similar to the V[P]GATHER*/V[P]SCATTER*
instructions.

.PP
Any attempt to execute the TILELOADD/TILELOADDT1 instructions inside an
Intel TSX transaction will result in a transaction abort.

.SH OPERATION
.EX
TILELOADD[,T1] tdest, tsib
start := tilecfg.start_row
zero_upper_rows(tdest,start)
membegin := tsib.base + displacement
// if no index register in the SIB encoding, the value zero is used.
stride := tsib.index << tsib.scale
nbytes := tdest.colsb
while start < tdest.rows:
    memptr := membegin + start * stride
    write_row_and_zero(tdest, start, read_memory(memptr, nbytes), nbytes)
    start := start + 1
zero_tilecfg_start()
// In the case of a memory fault in the middle of an instruction, the tilecfg.start_row := start
.EE

.SH INTEL C/C++ COMPILER INTRINSIC EQUIVALENT
.EX
TILELOADD void _tile_loadd(__tile dst, const void *base, int stride);

TILELOADDT1 void _tile_stream_loadd(__tile dst, const void *base, int stride);
.EE

.SH FLAGS AFFECTED
None.

.SH EXCEPTIONS
AMX-E3; see Section 2.10, “Intel® AMX Instruction Exception Classes,”
for details.

.SH SEE ALSO
x86-manpages(7) for a list of other x86-64 man pages.

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s Manual
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
MIT licensed by TTMO 2025 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
