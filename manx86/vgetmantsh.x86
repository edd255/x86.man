'\" t
.nh
.TH "X86-VGETMANTSH" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
VGETMANTSH - EXTRACT FP16 OF NORMALIZED MANTISSA FROM FP16 SCALAR
.TS
allbox;
l l l l l 
l l l l l .
\fBInstruction En Bit Mode Flag Support Instruction En Bit Mode Flag Support 64/32 CPUID Feature Instruction En Bit Mode Flag CPUID Feature Instruction En Bit Mode Flag Op/ 64/32 CPUID Feature Instruction En Bit Mode Flag 64/32 CPUID Feature Instruction En Bit Mode Flag CPUID Feature Instruction En Bit Mode Flag Op/ 64/32 CPUID Feature\fP	\fB\fP	\fBSupport\fP	\fB\fP	\fBDescription\fP
T{
EVEX.LLIG.NP.0F3A.W0 27 /r /ib VGETMANTSH xmm1{k1}{z}, xmm2, xmm3/m16 {sae}, imm8
T}	A	V/V	AVX512-FP16	T{
Extract the normalized mantissa of the low FP16 element in xmm3/m16 using imm8 for sign control and mantissa interval normalization. Store the mantissa to xmm1 subject to writemask k1 and merge with the other elements of xmm2. Bits 127:16 of xmm2 are copied to xmm1[127:16]\&.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l l 
l l l l l l .
\fBOp/En\fP	\fBTuple\fP	\fBOperand 1\fP	\fBOperand 2\fP	\fBOperand 3\fP	\fBOperand 4\fP
A	Scalar	ModRM:reg (w)	VEX.vvvv (r)	ModRM:r/m (r)	imm8 (r)
.TE

.SS Description
This instruction converts the FP16 value in the low element of the
second source operand to FP16 values with the mantissa normalization and
sign control specified by the imm8 byte, see Table 5-19. The converted
result is written to the low element of the destination operand using
writemask k1. The normalized mantissa is specified by interv
(imm8[1:0]) and the sign control (SC) is specified by bits 3:2 of the
immediate byte.

.PP
Bits 127:16 of the destination operand are copied from the corresponding
bits of the first source operand. Bits MAXVL-1:128 of the destination
operand are zeroed. The low FP16 element of the destination is updated
according to the writemask.

.PP
For each input FP16 value x, The conversion operation is:

.PP
GetMant(x) = ±2k|x.significand|

.PP
where:

.PP
1 ≤ |x.significand| &lt; 2

.PP
Unbiased exponent k depends on the interval range defined by interv and
whether the exponent of the source is even or odd. The sign of the final
result is determined by the sign control and the source sign and the
leading fraction bit.

.PP
The encoded value of imm8[1:0] and sign control are shown in Table
5-19.

.PP
Each converted FP16 result is encoded according to the sign control, the
unbiased exponent k (adding bias) and a mantissa normalized to the range
specified by interv.

.PP
The GetMant() function follows Table 5-20 when dealing with
floating-point special numbers.

.SS Operation
.SS VGETMANTSH dest{k1}, src1, src2, imm8
.EX
sign_control := imm8[3:2]
normalization_interval := imm8[1:0]
IF k1[0] or *no writemask*:
    dest.fp16[0] := getmant_fp16(src2.fp16[0],
            // see VGETMANTPH
        normalization_interval)
ELSE IF *zeroing*:
    dest.fp16[0] := 0
//else dest.fp16[0] remains unchanged
DEST[127:16] := src1[127:16]
DEST[MAXVL-1:128] := 0
.EE

.SS Intel C/C++ Compiler Intrinsic Equivalent
.EX
VGETMANTSH __m128h _mm_getmant_round_sh (__m128h a, __m128h b, _MM_MANTISSA_NORM_ENUM norm, _MM_MANTISSA_SIGN_ENUM sign, const int sae);

VGETMANTSH __m128h _mm_mask_getmant_round_sh (__m128h src, __mmask8 k, __m128h a, __m128h b, _MM_MANTISSA_NORM_ENUM norm, _MM_MANTISSA_SIGN_ENUM sign, const int sae);

VGETMANTSH __m128h _mm_maskz_getmant_round_sh (__mmask8 k, __m128h a, __m128h b, _MM_MANTISSA_NORM_ENUM norm, _MM_MANTISSA_SIGN_ENUM sign, const int sae);

VGETMANTSH __m128h _mm_getmant_sh (__m128h a, __m128h b, _MM_MANTISSA_NORM_ENUM norm, _MM_MANTISSA_SIGN_ENUM sign);

VGETMANTSH __m128h _mm_mask_getmant_sh (__m128h src, __mmask8 k, __m128h a, __m128h b, _MM_MANTISSA_NORM_ENUM norm, _MM_MANTISSA_SIGN_ENUM sign);

VGETMANTSH __m128h _mm_maskz_getmant_sh (__mmask8 k, __m128h a, __m128h b, _MM_MANTISSA_NORM_ENUM norm, _MM_MANTISSA_SIGN_ENUM sign);
.EE

.SS SIMD Floating-Point Exceptions
Invalid, Denormal

.SS Other Exceptions
EVEX-encoded instructions, see Table
2-47, “Type E3 Class Exception Conditions.”

.SH SEE ALSO
x86-manpages(7) for a list of other x86-64 man pages.

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s Manual
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
MIT licensed by TTMO 2025 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
