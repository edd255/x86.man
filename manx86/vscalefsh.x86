'\" t
.nh
.TH "X86-VSCALEFSH" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
VSCALEFSH - SCALE SCALAR FP16 VALUES WITH FP16 VALUES
.TS
allbox;
l l l l l 
l l l l l .
\fBInstruction En bit Mode Flag Support Instruction En bit Mode Flag Support 64/32 CPUID Feature Instruction En bit Mode Flag CPUID Feature Instruction En bit Mode Flag Op/ 64/32 CPUID Feature Instruction En bit Mode Flag 64/32 CPUID Feature Instruction En bit Mode Flag CPUID Feature Instruction En bit Mode Flag Op/ 64/32 CPUID Feature\fP	\fB\fP	\fBSupport\fP	\fB\fP	\fBDescription\fP
T{
EVEX.LLIG.66.MAP6.W0 2D /r VSCALEFSH xmm1{k1}{z}, xmm2, xmm3/m16 {er}
T}	A	V/V	AVX512-FP16	T{
Scale the FP16 values in xmm2 using the value from xmm3/m16 and store the result in xmm1 subject to writemask k1. Bits 127:16 from xmm2 are copied to xmm1[127:16]\&.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l l 
l l l l l l .
\fBOp/En\fP	\fBTuple\fP	\fBOperand 1\fP	\fBOperand 2\fP	\fBOperand 3\fP	\fBOperand 4\fP
A	Scalar	ModRM:reg (w)	VEX.vvvv (r)	ModRM:r/m (r)	N/A
.TE

.SS Description
This instruction performs a floating-point scale of the low FP16 element
in the first source operand by multiplying it by 2 to the power of the
low FP16 element in second source operand, storing the result in the low
element of the destination operand.

.PP
Bits 127:16 of the destination operand are copied from the corresponding
bits of the first source operand. Bits MAXVL-1:128 of the destination
operand are zeroed. The low FP16 element of the destination is updated
according to the writemask.

.PP
The equation of this operation is given by:

.PP
xmm1 := xmm2 * 2floor(xmm3).

.PP
Floor(xmm3) means maximum integer value ≤ xmm3.

.PP
If the result cannot be represented in FP16, then the proper overflow
response (for positive scaling operand), or the proper underflow
response (for negative scaling operand), is issued. The overflow and
underflow responses are dependent on the rounding mode (for
IEEE-compliant rounding), as well as on other settings in MXCSR
(exception mask bits, FTZ bit), and on the SAE bit.

.PP
Handling of special-case input values are listed in Table 5-42.

.SS Operation
.SS VSCALEFSH dest{k1}, src1, src2
.EX
IF (EVEX.b = 1) and no memory operand:
    SET_RM(EVEX.RC)
ELSE
    SET_RM(MXCSR.RC)
IF k1[0] or *no writemask*:
    dest.fp16[0] := scale_fp16(src1.fp16[0], src2.fp16[0]) // see VSCALEFPH
ELSE IF *zeroing*:
    dest.fp16[0] := 0
//else DEST.fp16[0] remains unchanged
DEST[127:16] := src1[127:16]
DEST[MAXVL-1:128] := 0
.EE

.SS Intel C/C++ Compiler Intrinsic Equivalent
.EX
VSCALEFSH __m128h _mm_mask_scalef_round_sh (__m128h src, __mmask8 k, __m128h a, __m128h b, const int rounding);

VSCALEFSH __m128h _mm_maskz_scalef_round_sh (__mmask8 k, __m128h a, __m128h b, const int rounding);

VSCALEFSH __m128h _mm_scalef_round_sh (__m128h a, __m128h b, const int rounding);

VSCALEFSH __m128h _mm_mask_scalef_sh (__m128h src, __mmask8 k, __m128h a, __m128h b);

VSCALEFSH __m128h _mm_maskz_scalef_sh (__mmask8 k, __m128h a, __m128h b);

VSCALEFSH __m128h _mm_scalef_sh (__m128h a, __m128h b);
.EE

.SS SIMD Floating-Point Exceptions
Invalid, Underflow, Overflow, Precision, Denormal.

.SS Other Exceptions
EVEX-encoded instructions, see Table
2-47, “Type E3 Class Exception Conditions.”

.PP
Denormal-operand exception (#D) is checked and signaled for src1
operand, but not for src2 operand. The denormal-operand exception is
checked for src1 operand only if the src2 operand is not NaN. If the
src2 operand is NaN, the processor generates NaN and does not signal
denormal-operand exception, even if src1 operand is denormal.

.SH SEE ALSO
x86-manpages(7) for a list of other x86-64 man pages.

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s Manual
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
MIT licensed by TTMO 2025 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
