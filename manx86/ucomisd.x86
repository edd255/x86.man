'\" t
.nh
.TH "X86-UCOMISD" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
UCOMISD - UNORDERED COMPARE SCALAR DOUBLE PRECISION FLOATING-POINT VALUES AND SET EFLAGS
.TS
allbox;
l l l l l 
l l l l l .
\fBOpcode/Instruction\fP	\fBOp / En\fP	\fB64/32 bit Mode Support\fP	\fBCPUID Feature Flag\fP	\fBDescription\fP
T{
66 0F 2E /r UCOMISD xmm1, xmm2/m64
T}	A	V/V	SSE2	T{
Compare low double precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly.
T}
T{
VEX.LIG.66.0F.WIG 2E /r VUCOMISD xmm1, xmm2/m64
T}	A	V/V	AVX	T{
Compare low double precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly.
T}
T{
EVEX.LLIG.66.0F.W1 2E /r VUCOMISD xmm1, xmm2/m64{sae}
T}	B	V/V	AVX512F	T{
Compare low double precision floating-point values in xmm1 and xmm2/m64 and set the EFLAGS flags accordingly.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l l 
l l l l l l .
\fBOp/En\fP	\fBTuple Type\fP	\fBOperand 1\fP	\fBOperand 2\fP	\fBOperand 3\fP	\fBOperand 4\fP
A	N/A	ModRM:reg (r)	ModRM:r/m (r)	N/A	N/A
B	Tuple1 Scalar	ModRM:reg (w)	ModRM:r/m (r)	N/A	N/A
.TE

.SH DESCRIPTION
Performs an unordered compare of the double precision floating-point
values in the low quadwords of operand 1 (first operand) and operand 2
(second operand), and sets the ZF, PF, and CF flags in the EFLAGS
register according to the result (unordered, greater than, less than, or
equal). The OF, SF, and AF flags in the EFLAGS register are set to 0.
The unordered result is returned if either source operand is a NaN (QNaN
or SNaN).

.PP
Operand 1 is an XMM register; operand 2 can be an XMM register or a 64
bit memory

.PP
location.

.PP
The UCOMISD instruction differs from the COMISD instruction in that it
signals a SIMD floating-point invalid operation exception (#I) only when
a source operand is an SNaN. The COMISD instruction signals an invalid
operation exception only if a source operand is either an SNaN or a
QNaN.

.PP
The EFLAGS register is not updated if an unmasked SIMD floating-point
exception is generated.

.PP
Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise
instructions will #UD.

.PP
Software should ensure VCOMISD is encoded with VEX.L=0. Encoding VCOMISD
with VEX.L=1 may encounter unpredictable behavior across different
processor generations.

.SH OPERATION
.SS (V)UCOMISD (All Versions)
.EX
RESULT := UnorderedCompare(DEST[63:0] <> SRC[63:0]) {
(* Set EFLAGS *) CASE (RESULT) OF
    UNORDERED: ZF,PF,CF := 111;
    GREATER_THAN: ZF,PF,CF := 000;
    LESS_THAN: ZF,PF,CF := 001;
    EQUAL: ZF,PF,CF := 100;
ESAC;
OF, AF, SF := 0; }
.EE

.SH INTEL C/C++ COMPILER INTRINSIC EQUIVALENT
.EX
VUCOMISD int _mm_comi_round_sd(__m128d a, __m128d b, int imm, int sae);

UCOMISD int _mm_ucomieq_sd(__m128d a, __m128d b)

UCOMISD int _mm_ucomilt_sd(__m128d a, __m128d b)

UCOMISD int _mm_ucomile_sd(__m128d a, __m128d b)

UCOMISD int _mm_ucomigt_sd(__m128d a, __m128d b)

UCOMISD int _mm_ucomige_sd(__m128d a, __m128d b)

UCOMISD int _mm_ucomineq_sd(__m128d a, __m128d b)
.EE

.SH SIMD FLOATING-POINT EXCEPTIONS
Invalid (if SNaN operands), Denormal.

.SH OTHER EXCEPTIONS
VEX-encoded instructions, see Table
2-20, “Type 3 Class Exception Conditions,” additionally:

.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	If VEX.vvvv != 1111B.
.TE

.PP
EVEX-encoded instructions, see Table
2-48, “Type E3NF Class Exception Conditions.”

.SH SEE ALSO
x86-manpages(7) for a list of other x86-64 man pages.

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s Manual
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
MIT licensed by TTMO 2025 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
