'\" t
.nh
.TH "X86-PREFETCHW" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
PREFETCHW - PREFETCH DATA INTO CACHES IN ANTICIPATION OF A WRITE
.TS
allbox;
l l l l l 
l l l l l .
\fBOpcode/Instruction\fP	\fBOp/En\fP	\fB64/32 bit Mode Support\fP	\fBCPUID Feature Flag\fP	\fBDescription\fP
0F 0D /1 PREFETCHW m8	M	V/V	PREFETCHW	T{
Move data from m8 closer to the processor in anticipation of a write.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l 
l l l l l .
\fBOp/En\fP	\fBOperand 1\fP	\fBOperand 2\fP	\fBOperand 3\fP	\fBOperand 4\fP
M	ModRM:r/m (r)	N/A	N/A	N/A
.TE

.SH DESCRIPTION
Fetches the cache line of data from memory that contains the byte
specified with the source operand to a location in the 1st or 2nd level
cache and invalidates other cached instances of the line.

.PP
The source operand is a byte memory location. If the line selected is
already present in the lowest level cache and is already in an
exclusively owned state, no data movement occurs. Prefetches from
non-writeback memory are ignored.

.PP
The PREFETCHW instruction is merely a hint and does not affect program
behavior. If executed, this instruction moves data closer to the
processor and invalidates other cached copies in anticipation of the
line being written to in the future.

.PP
The characteristic of prefetch locality hints is
implementation-dependent, and can be overloaded or ignored by a
processor implementation. The amount of data prefetched is also
processor implementation-dependent. It will, however, be a minimum of 32
bytes. Additional details of the implementation-dependent locality hints
are described in Section 7.4 of Intel® 64 and IA-32 Architectures
Optimization Reference Manual.

.PP
It should be noted that processors are free to speculatively fetch and
cache data with exclusive ownership from system memory regions that
permit such accesses (that is, the WB memory type). A PREFETCHW
instruction is considered a hint to this speculative behavior. Because
this speculative fetching can occur at any time and is not tied to
instruction execution, a PREFETCHW instruction is not ordered with
respect to the fence instructions (MFENCE, SFENCE, and LFENCE) or locked
memory references. A PREFETCHW instruction is also unordered with
respect to CLFLUSH and CLFLUSHOPT instructions, other PREFETCHW
instructions, or any other general instruction

.PP
It is ordered with respect to serializing instructions such as CPUID,
WRMSR, OUT, and MOV CR.

.PP
This instruction's operation is the same in non-64-bit modes and 64-bit
mode.

.SH OPERATION
.EX
FETCH_WITH_EXCLUSIVE_OWNERSHIP (m8);
.EE

.SH FLAGS AFFECTED
None.

.SH C/C++ COMPILER INTRINSIC EQUIVALENT
.EX
void _m_prefetchw( void * );
.EE

.SH PROTECTED MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	If the LOCK prefix is used.
.TE

.SH REAL-ADDRESS MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	If the LOCK prefix is used.
.TE

.SH VIRTUAL-8086 MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	If the LOCK prefix is used.
.TE

.SH COMPATIBILITY MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	If the LOCK prefix is used.
.TE

.SH 64-BIT MODE EXCEPTIONS
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	If the LOCK prefix is used.
.TE

.SH SEE ALSO
x86-manpages(7) for a list of other x86-64 man pages.

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s Manual
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
MIT licensed by TTMO 2025 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
