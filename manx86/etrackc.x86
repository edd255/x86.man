'\" t
.nh
.TH "X86-ETRACKC" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
ETRACKC - ACTIVATES EBLOCK CHECKS
.TS
allbox;
l l l l l 
l l l l l .
\fBOpcode/Instruction\fP	\fBOp/En\fP	\fB64/32 bit Mode Support\fP	\fBCPUID Feature Flag\fP	\fBDescription\fP
EAX = 11H ENCLS[ETRACKC]	IR	V/V	EAX[6]	T{
This leaf function activates EBLOCK checks.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING
.TS
allbox;
l l l l l 
l l l l l .
\fB\fP	\fB\fP	\fB\fP	\fB\fP	\fB\fP
Op/En	EAX		RCX	
IR	ETRACK (In)	Return error code (Out)	T{
Address of the destination EPC page (In, EA)
T}	T{
Address of the SECS page (In, EA)
T}
.TE

.SS Description
The ETRACKC instruction is thread safe variant of ETRACK leaf and can be
executed concurrently with other CPU threads operating on the same SECS.

.PP
This leaf function provides the mechanism for hardware to track that
software has completed the required TLB address clears successfully. The
instruction can only be executed when the current privilege level is 0.

.PP
The content of RCX is an effective address of an EPC page.

.PP
The table below provides additional information on the memory parameter
of ETRACK leaf function.

.SH ETRACKC MEMORY PARAMETER SEMANTICS
.TS
allbox;
l 
l .
\fB\fP
EPCPAGE
T{
Read/Write access permitted by Enclave
T}
.TE

.PP
The error codes are:

.SS Concurrency Restrictions
.SS Operation
.SH TEMP VARIABLES IN ETRACKC OPERATIONAL FLOW
.TS
allbox;
l l l l 
l l l l .
\fBName\fP	\fBType\fP	\fBSize (Bits)\fP	\fBDescription\fP
TMP_SECS	Physical Address	64	T{
Physical address of the SECS of the page being modified.
T}
.TE

.PP
(* check alignment of EPCPAGE (RCX) *)

.PP
IF (DS:RCX is not 4KByte Aligned) THEN

.PP
#GP(0); FI;

.PP
(* check that EPCPAGE (DS:RCX) is the address of an EPC page *)

.PP
IF (DS:RCX does not resolve within an EPC) THEN

.PP
#PF(DS:RCX, PFEC.SGX); FI;

.PP
(* Check the EPC page for concurrency *)

.PP
IF (EPC page is being modified) THEN

.PP
RFLAGS.ZF := 1;

.PP
RFLAGS.CF := 0;

.PP
RAX := SGX_EPC_PAGE_CONFLICT;

.PP
goto DONE_POST_LOCK_RELEASE;

.PP
FI;

.PP
(* check to make sure the page is valid *)

.PP
IF (EPCM(DS:RCX).VALID = 0) THEN

.PP
RFLAGS.ZF := 1;

.PP
RFLAGS.CF := 0;

.PP
RAX := SGX_PG_INVLD;

.PP
GOTO DONE;

.PP
FI;

.PP
(* find out the target SECS page *)

.PP
IF (EPCM(DS:RCX).PT is PT_REG or PT_TCS or PT_TRIM or PT_SS_FIRST
or PT_SS_REST) THEN

.PP
TMP_SECS := Obtain SECS through EPCM(DS:RCX).ENCLAVESECS;

.PP
ELSE IF (EPCM(DS:RCX).PT is PT_SECS) THEN

.PP
TMP_SECS := Obtain SECS through (DS:RCX);

.PP
ELSE

.PP
RFLAGS.ZF := 0;

.PP
RFLAGS.CF := 1;

.PP
RAX := SGX_TRACK_NOT_REQUIRED;

.PP
GOTO DONE;

.PP
FI;

.PP
(* Check concurrency with other Intel SGX instructions *)

.PP
IF (Other Intel SGX instructions using tracking facility on this SECS)
THEN

.PP
IF ((VMX non-root mode) and

.PP
(ENABLE_EPC_VIRTUALIZATION_EXTENSIONS Execution Control = 1)) THEN

.PP
VMCS.Exit_reason := SGX_CONFLICT;

.PP
VMCS.Exit_qualification.code := TRACKING_RESOURCE_CONFLICT;

.PP
VMCS.Exit_qualification.error := 0;

.PP
VMCS.Guest-physical_address :=

.PP
SECS(TMP_SECS).ENCLAVECONTEXT;

.PP
VMCS.Guest-linear_address := 0;

.PP
Deliver VMEXIT;

.PP
FI;

.PP
RFLAGS.ZF := 1;

.PP
RFLAGS.CF := 0;

.PP
RAX := SGX_EPC_PAGE_CONFLICT;

.PP
GOTO DONE;

.PP
FI;

.PP
(* All processors must have completed the previous tracking cycle*)

.PP
IF ( (TMP_SECS).TRACKING ≠ 0) )

.PP
THEN

.PP
IF ((VMX non-root mode) and

.PP
(ENABLE_EPC_VIRTUALIZATION_EXTENSIONS Execution Control = 1)) THEN

.PP
VMCS.Exit_reason := SGX_CONFLICT;

.PP
VMCS.Exit_qualification.code := TRACKING_REFERENCE_CONFLICT;

.PP
VMCS.Exit_qualification.error := 0;

.PP
VMCS.Guest-physical_address :=

.PP
SECS(TMP_SECS).ENCLAVECONTEXT;

.PP
VMCS.Guest-linear_address := 0;

.PP
Deliver VMEXIT;

.PP
FI;

.PP
RFLAGS.ZF := 1;

.PP
RFLAGS.CF := 0;

.PP
RAX := SGX_PREV_TRK_INCMPL;

.PP
GOTO DONE;

.PP
FI;

.PP
RFLAGS.ZF := 0;

.PP
RFLAGS.CF := 0;

.PP
RAX := 0;

.PP
DONE:

.PP
(* clear flags *)

.PP
RFLAGS.PF,AF,OF,SF := 0;

.SS Flags Affected
ZF is set if ETRACKC fails due to concurrent operations with another SGX
instructions or target page is an invalid EPC page or tracking is not
completed on SECS page; otherwise cleared.

.PP
CF is set if target page is not of a type that requires tracking;
otherwise cleared.

.PP
PF, AF, OF, and SF are cleared.

.SS Protected Mode Exceptions
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#GP(0)	T{
If the memory operand violates access-control policies of DS segment.
T}
	If DS segment is unusable.
	T{
If the memory operand is not properly aligned.
T}
#PF(error	T{
code) If the memory operand expected to be in EPC does not resolve to an EPC page.
T}
	T{
If a page fault occurs in access memory operand.
T}
.TE

.SS 64-Bit Mode Exceptions
.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#GP(0)	T{
If a memory address is in a non-canonical form.
T}
	T{
If a memory operand is not properly aligned.
T}
#PF(error	T{
code) If the memory operand expected to be in EPC does not resolve to an EPC page.
T}
	T{
If a page fault occurs in access memory operand.
T}
.TE

.SH SEE ALSO
x86-manpages(7) for a list of other x86-64 man pages.

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s Manual
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
MIT licensed by TTMO 2025 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
