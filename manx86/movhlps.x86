'\" t
.nh
.TH "X86-MOVHLPS" "7" "May 2019" "TTMO" "Intel x86-64 ISA Manual"
.SH NAME
MOVHLPS - MOVE PACKED SINGLE PRECISION FLOATING-POINT VALUES HIGH TO LOW
.TS
allbox;
l l l l l 
l l l l l .
\fBOpcode/Instruction\fP	\fBOp / En\fP	\fB64/32 bit Mode Support\fP	\fBCPUID Feature Flag\fP	\fBDescription\fP
NP 0F 12 /r MOVHLPS xmm1, xmm2	RM	V/V	SSE	T{
Move two packed single precision floating-point values from high quadword of xmm2 to low quadword of xmm1.
T}
T{
VEX.128.0F.WIG 12 /r VMOVHLPS xmm1, xmm2, xmm3
T}	RVM	V/V	AVX	T{
Merge two packed single precision floating-point values from high quadword of xmm3 and low quadword of xmm2.
T}
T{
EVEX.128.0F.W0 12 /r VMOVHLPS xmm1, xmm2, xmm3
T}	RVM	V/V	AVX512F	T{
Merge two packed single precision floating-point values from high quadword of xmm3 and low quadword of xmm2.
T}
.TE

.SH INSTRUCTION OPERAND ENCODING1
.PP
.RS

.PP
1\&. ModRM.MOD = 011B required.

.RE

.TS
allbox;
l l l l l 
l l l l l .
\fBOp/En\fP	\fBOperand 1\fP	\fBOperand 2\fP	\fBOperand 3\fP	\fBOperand 4\fP
RM	ModRM:reg (w)	ModRM:r/m (r)	N/A	N/A
RVM	ModRM:reg (w)	VEX.vvvv (r) / EVEX.vvvv (r)	ModRM:r/m (r)	N/A
.TE

.SH DESCRIPTION
This instruction cannot be used for memory to register moves.

.PP
128-bit two-argument form:

.PP
Moves two packed single precision floating-point values from the high
quadword of the second XMM argument (second operand) to the low quadword
of the first XMM register (first argument). The quadword at bits 127:64
of the destination operand is left unchanged. Bits (MAXVL-1:128) of the
corresponding destination register remain unchanged.

.PP
128-bit and EVEX three-argument form:

.PP
Moves two packed single precision floating-point values from the high
quadword of the third XMM argument (third operand) to the low quadword
of the destination (first operand). Copies the high quadword from the
second XMM argument (second operand) to the high quadword of the
destination (first operand). Bits (MAXVL-1:128) of the corresponding
destination register are zeroed.

.PP
If VMOVHLPS is encoded with VEX.L or EVEX.L’L= 1, an attempt to execute
the instruction encoded with VEX.L or EVEX.L’L= 1 will cause an #UD
exception.

.SH OPERATION
.SS MOVHLPS (128-bit Two-Argument Form)
.EX
DEST[63:0] := SRC[127:64]
DEST[MAXVL-1:64] (Unmodified)
.EE

.SS VMOVHLPS (128-bit Three-Argument Form - VEX & EVEX)
.EX
DEST[63:0] := SRC2[127:64]
DEST[127:64] := SRC1[127:64]
DEST[MAXVL-1:128] := 0
.EE

.SH INTEL C/C++ COMPILER INTRINSIC EQUIVALENT
.EX
MOVHLPS __m128 _mm_movehl_ps(__m128 a, __m128 b)
.EE

.SH SIMD FLOATING-POINT EXCEPTIONS
None.

.SH OTHER EXCEPTIONS
Non-EVEX-encoded instruction, see Table
2-24, “Type 7 Class Exception Conditions,” additionally:

.TS
allbox;
l l 
l l .
\fB\fP	\fB\fP
#UD	If VEX.L = 1.
.TE

.PP
EVEX-encoded instruction, see Exceptions Type E7NM.128 in
Table 2-55, “Type E7NM Class Exception
Conditions.”

.SH SEE ALSO
x86-manpages(7) for a list of other x86-64 man pages.

.SH COLOPHON
This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be
incomplete or
broken in various obvious or non-obvious ways.
Refer to Intel® 64 and IA-32 Architectures Software Developer’s Manual
for anything serious.

.br
This page is generated by scripts; therefore may contain visual or semantical bugs. Please report them (or better, fix them) on https://github.com/ttmo-O/x86-manpages.

.br
MIT licensed by TTMO 2025 (Turkish Unofficial Chamber of Reverse Engineers - https://ttmo.re).
